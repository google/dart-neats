// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import 'dart:io' show Directory, IOException;
import 'package:vendor/src/config.dart' show VendorState, VendorConfig;
import 'package:vendor/src/exceptions.dart';
import 'package:vendor/src/version.dart' show packageVersion;
import 'package:pub_semver/pub_semver.dart' show Version;

final _version = Version.parse(packageVersion);

final _namePattern = RegExp(r'^[a-z_][a-z0-9_]*$');

void _validatePackageName(String name) {
  if (!_namePattern.hasMatch(name)) {
    throw FormatException('Invalid package name "$name"');
  }
}

/// Validate [config], throw [FormatException] if there's issues.
void validateConfig(VendorConfig config) {
  // Check that rewrites a valid
  void validateRewrites(Map<String, String> rewrites) {
    final inverted = <String, String>{};
    rewrites.forEach((from, to) {
      _validatePackageName(from);

      if (!config.dependencies.containsKey(to)) {
        throw FormatException(
          'Cannot rewrite import package:$from to vendored package '
          '$to, so such vendored package configured',
        );
      }

      // Don't allow two different package names to point to the same vendored
      // package. This cannot be reversed. It could also cause problems in the
      // code importing these packages.
      if (inverted.containsKey(to)) {
        throw FormatException(
          'Cannot rewrite both package:${inverted[to]} and package:$from to '
          'vendored package $to, such rewrite would be irreversible',
        );
      }
      inverted[to] = from;
    });
  }

  validateRewrites(config.rewrites);

  config.dependencies.forEach((name, source) {
    _validatePackageName(name);
    validateRewrites(source.rewrites);

    if (source.rewrites.containsKey(source.package)) {
      throw FormatException(
        'Vendored package $name cannot rewrite imports for '
        'package:${source.package}, self-imports will always be rewritten',
      );
    }
  });
}

/// Validate [VendorState] throws [VendorFailure] if validation fails.
///
/// This doesn't check the state of all vendored packages. It merely aims catch
/// obvious issues, such as state files from future versions of
/// `package:vendor`, missing directories or invalid configuration.
Future<void> validateState(VendorState state, Uri rootPackageFolder) async {
  // Check that state wasn't written by a future version of the vendor
  if (state.version >= _version.nextMinor) {
    throw VendorFailure(
      ExitCode.data,
      'package:vendor version $_version cannot read '
      'lib/src/third_party/vendor-state.yaml generated by package:vendor '
      'version ${state.version}. Please upgrade package:vendor.',
    );
  }
  if (state.version < _version) {
    // Apply any upgrade operations necessary
  }

  // Find all directories in lib/src/third_party/
  final directories = <String>{};
  final vendorFolder = rootPackageFolder.resolve('lib/src/third_party/');
  try {
    final entries = Directory.fromUri(vendorFolder)
        .list(followLinks: false, recursive: false);
    await for (final entry in entries) {
      if (entry is Directory) {
        directories.add(
          // Take the last pathSegment that isn't empty, the empty string occurs
          // when there is a trailing slash (which directories have,)
          entry.uri.normalizePath().pathSegments.lastWhere((s) => s.isNotEmpty),
        );
      }
    }
  } on IOException {
    /* ignore */
  }

  // Check that lib/src/third_party/<name>/ exists for each vendored package
  final missingVendoredPackages = state.config.dependencies.keys
      .where((p) => !directories.contains(p))
      .toSet();
  if (missingVendoredPackages.isNotEmpty) {
    throw VendorFailure(
      ExitCode.data,
      'lib/src/third_party/vendor-state.yaml is inconsistent with directories '
      'in lib/src/third_party/. Directories for the following vendored '
      'packages is missing: ${missingVendoredPackages.join(', ')}. '
      'Restore consistent state or re-initiate vendoring from scratch!',
    );
  }

  // Check that the stored configuration is valid!
  try {
    validateConfig(state.config);
  } on FormatException catch (e) {
    throw VendorFailure(
      ExitCode.data,
      'lib/src/third_party/vendor-state.yaml contains invalid configuration. '
      'This state file was not generated by package:vendor. Following '
      'configuration is broken: ${e.message}',
    );
  }
}
